#!/bin/bash
#
# build up a git repo while appling the fedora kernel patches
# Author: Cristian Gafton <gafton@amazon.com>

# color in the output helps a lot with parsing
_grn="$(echo -en '\033[1;32m')"  # green
_red="$(echo -en '\033[1;31m')"  # red
_yel="$(echo -en '\033[1;33m')"  # yellow
_def="$(echo -en '\033[0;39m')"  # normal
say_red()    { echo -e "${_red}${1:-}${_def}" ; }
say_green()  { echo -e "${_grn}${1:-}${_def}" ; }
say_yellow() { echo -e "${_yel}${1:-}${_def}" ; }

trap 'say_red "script exited with ERROR: $BASH_COMMAND"' ERR
set -e -x

DEFAULT_AUTHOR="RPM Patch <kernel@fedoraproject.org>"

LINUX_DIR=@@LINUX_DIR@@
VTAG=@@VTAG@@
TAGVER=@@TAGVER@@
UPSTREAM=@@UPSTREAM@@

PATCH_ARGS=
STAGE=patch
PATCHIN=
while [ $# -gt 0 ] ; do
    case $1 in
        -p* | -F* | -R | -s ) PATCH_ARGS="$PATCH_ARGS $1" ;;
        --start ) STAGE=start ;;
        --finish ) STAGE=finish ;;
        --patch=* )
        patch=${1##--patch=}
        export patch
        PATCHIN="$RPM_SOURCEDIR/${patch}"
        ;;
        * ) say_yellow "Ignoring patch option: $1" ;;
    esac
    shift
done

# defines we will capture later in the linux.vars file
BRANCH="${UPSTREAM}/${TAGVER}"

function add_changes {
    # try to figure out what the patch did...
    find . \( -name \*.orig -o -name \*.rej \) -exec rm -fv {} \;
    git add --all --force .
    # also marked as removed in git the stuff that was removed...
    git status --short | grep -E '^.D' | awk '{print $2}' | xargs -r git rm
}

function git_unstash {
    # undo a previous stash to keep the state of the tree clean
    while  [ -n "$(git stash list)" ] ; do
        git stash pop --quiet
    done
}

function git_stash {
    # attempt to save the state of tree changes done via non-patch actions
    # (such as copying stuff in between patches, etc)
    add_changes
    if [ $(git status --short|wc -l) -gt 0 ] ; then
        # stash the changes away
        git stash
    fi
}

function start_tree {
    # clone out the stable linux tree
    local b=$(basename $(pwd -P))
    pushd ..
    rm -rf $b.git
    say_yellow "Cloning ${dir} for $b"
    git clone --no-hardlinks $LINUX_DIR $b.git
    cd $b.git
    # check that the branch does not already exists
    if ! git show-ref --verify --quiet refs/tags/$VTAG ; then
        say_red "Can not find tag $VTAG"
        exit -1
    fi
    if git show-ref --verify --quiet refs/remotes/origin/$BRANCH ; then
        say_red "Branch $BRANCH already exists"
        exit -1
    fi
    git checkout -b $BRANCH $VTAG
    popd
    # safety check
    if [ -d ./.git/ ] ; then
        say_red "ERROR: attempting to override internal .git directory with ../$b.git/.git/"
        exit -2
    fi
    # now bring over changes from the unpacked tree
    rsync -aH --delete-after ../$b.git/.git/ ./.git/
    rm -rf ../$b.git
    git_stash
}

function clean_tree {
    git clean -fdx
}

function commit_tree {
    local msg=${1:-"[${UPSTREAM}] patch from stdin"}
    add_changes
    local z=$(git status --short)
    local phead=
    if [ -n "$ptmp" ] ; then
        phead=$(sed -n -r -e '0,/^(--$|diff -|--- )/p;' <$ptmp | \
            sed -r -e 's/^(.*)$/  \1/')
    fi
    local _author=
    local _msg=
    if [ -n "${phead}" ] ; then
        local _author=$(sed -n -r -e '0,/^(--$|diff -|--- )/p;' <$ptmp | \
            sed -r -e '/From: /!d;s|\s*From:\s*(.+)$|\1|' \
                   -e 's|(\S)[<]|\1 <|')
        # ignore multiple lines From: 
        if [[ ! "$_author" =~ ^.*\<.*@.*\>$ ]]; then
            unset -v _author
        fi
        local _msg=$(sed -n -r -e '0,/^(--$|diff -|--- )/p;' <$ptmp | \
            sed -r -e '/Subject: /!d;s|\s*Subject:\s*(.+)$|\1|')
    fi
    if [ -n "${z}" ] ; then
        cat <<EOF | git commit -s --author="${_author:-$DEFAULT_AUTHOR}" --file=-
${_msg:-$msg}

$(git diff --cached --stat)
${phead}
EOF
    fi
}

function commit_tree_if_needed {
    local msg=$1
    if [ $(git status --short|wc -l) -gt 0 ] ; then
        commit_tree "${msg}"
    fi
}

function finish_tree {
    ptmp=
    topdir=$(git rev-parse --show-toplevel)
    pushd linux-*.${RPM_ARCH}
    # clean up the state of the extra files put in the tree by the spec file
    # prep process
    make distclean
    add_changes
    git reset
    git push origin HEAD && \
        git push origin --tags
    # generate the linux.vers file
    popd
    say_yellow "Updating the linux.vers file..."
    cat >${topdir}/linux.vers <<EOF
linux_TAGVER     = ${VTAG##v}
linux_TAR_BASE   = v\$(linux_TAGVER)
linux_PATCH_BASE = \$(linux_TAR_BASE)
linux_BRANCH     = ${BRANCH}
linux_PATCH_HEAD = \$(linux_BRANCH)

# generate changelog entries only for commits to these items
builder_LOGS     = linux.vers srpm/ template/
EOF
}

function patch_tree {
    git_stash
    clean_tree
    say_yellow "processing patch ${patch:-from stdin}"
    if [ -n "$patch" ] ; then
        if ! git am $ptmp ; then
            if [ -d .git/rebase-apply ] ; then
                say_yellow "failed to process $patch with git am... trying regular patch"
                git am --abort
            fi
            clean_tree
            /usr/bin/patch $PATCH_ARGS <$ptmp
            commit_tree "[${UPSTREAM}] patch ${patch%%.patch}"
        else
            say_green "patch $patch applied with 'git am'"
        fi
    else
        /usr/bin/patch $PATCH_ARGS <$ptmp
        commit_tree
    fi
    git_unstash
}

###
### MAIN
###
case $STAGE in
    start ) start_tree ;;
    finish ) finish_tree ;;
    patch )
        # capture the stdin into a temp file
        ptmp=$(mktemp $RPM_SOURCE_DIR/pXXXXXX)
        trap "rm -f $ptmp" 0 9 15
        if [ -n "$patch" -a -n "$PATCHIN" ] ; then 
            case $patch in
                *gz ) zcat $PATCHIN >$ptmp ;;
                *bz2 ) bzcat $PATCHIN >$ptmp ;;
                *xz ) xzcat $PATCHIN >$ptmp ;;
                * ) sed -e '/\S/,$!d;' $PATCHIN >$ptmp ;;
            esac
        else
            sed -e '/\S/,$!d;' >$ptmp
        fi
        if [ ! -d .git ] ; then
            start_tree
        fi
        patch_tree
        rm -f $ptmp
        clean_tree
        ;;
    * )
        say_red "ERROR: unknonw stage: '$STAGE'"
        exit -1
esac
